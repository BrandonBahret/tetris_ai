import numpy as np
import copy
import time

from Agent.Tetromino import Tetromino

from Types.NumbaDefinitions import MoveDescriptionTuple


class MoveDescription:
    '''Move Descriptions are generated by the Game Agent to communicate intent to the Agent Controller.'''

    def __init__(self, destinations:list, target_placement:np.array, target_outcome: np.array, target_placement_simple: np.array):
        self.move_start_t = time.time()
        self._move_complete = False
        self.destinations = destinations
        self.progress_index = 0

        self._target_placement = target_placement.copy()
        self._target_placement_simple = target_placement_simple.copy()
        self._target_outcome = target_outcome.copy()

    def copy(self):
        return copy.deepcopy(self)

    @property
    def target_placement(self):
        return self._target_placement.copy()

    @property
    def target_placement_simple(self):
        return self._target_placement_simple.copy()

    @property
    def target_outcome(self):
        return self._target_outcome.copy()

    @property
    def destination(self) -> Tetromino:
        if self.progress_index >= len(self.destinations):
            self.mark_complete()

        if self._move_complete:
            return None
        
        current_destination = self.destinations[self.progress_index]
        # if self.progress_index > 0:
        #     current_destination.mark_as_held(False)
        return current_destination

    # @property
    def vertical_distance_from_destination(self, active_piece):
        target_x, target_y = self.destination.position
        active_x, active_y = active_piece.position
        return target_y - active_y

    @property
    def is_last_step(self):
        return self.progress_index == (len(self.destinations)-1)

    @property
    def move_complete(self):
        if self._move_complete:
            return True
        
        if self.destination is None:
            self.mark_complete()
            return True

        return False

    def mark_complete(self):
        self._move_complete = True

    def check_lifetime(self):
        return time.time() - self.move_start_t

    def increment_progress_index(self):
        self.progress_index += 1
        
    def check_progress(self, active_piece:Tetromino):
        if active_piece == self.destination:
            self.progress_index += 1

    @staticmethod
    def numba_move_to_py(np_move:MoveDescriptionTuple.type):
        destinations = []
        for dest in np_move.destinations:
            each_destination = Tetromino.numba_tetromino_to_py(dest)
            destinations.append(each_destination)

        target_placement = np_move.target_placement
        target_outcome = np_move.target_outcome
        target_placement_simple = np_move.target_placement_simple

        return MoveDescription(destinations, target_placement, target_outcome, target_placement_simple)
